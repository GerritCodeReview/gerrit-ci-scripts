import groovy.json.*
import java.io.FileNotFoundException
import java.text.*
import jenkins.model.*

class Config {
    static String gerrit = "https://gerrit-review.googlesource.com/"
    static String repository = "gerrit"
    static String gitUser = "Jenkins Build"
    static String gitEmail = "jenkins@gerritforge.com"
    static long curlTimeout = 10000
    static int retryTimes = 3
    static Set<String> codeStyleBranches = ["master", "stable-2.14", "stable-2.15"]
    static String addVerifiedTag = " \"tag\" : \"autogenerated:gerrit-ci:addVerified\" "
    static resTicks = [ 'ABORTED':'\u26aa', 'SUCCESS':'\u2705', 'FAILURE':'\u274c' ]
    static boolean verbose = true
}

class Change {
    static Map changeJson = [:]
    static Map metaData = [:]
}

class Builds {
    static String tool = ""
    static Set<String> modes = ["reviewdb"]
    static Result resultCodeStyle = null
    static Run buildCodeStyle = null
    static Map resultsVerification = [:]
    static Map buildsVerification = [:]
}

def postToGerrit(url, jsonPayload) {
    def error = ""
    def gerritPostUrl = Config.gerrit + url
    def curl = ['curl',
    '-n', '-s', '-S',
    '-X', 'POST', '-H', 'Content-Type: application/json',
    '--data-binary', jsonPayload,
        gerritPostUrl ]
    if(Config.verbose) { println "CURL/EXEC> ${curl}" }
    def proc = curl.execute()
    def sout = new StringBuffer(), serr = new StringBuffer()
    proc.consumeProcessOutput(sout, serr)
    proc.waitForOrKill(Config.curlTimeout)
    def curlExit = proc.exitValue()
    if(curlExit != 0) {
        error = "${curl} **FAILED** with exit code = ${curlExit}"
        println error
        throw new IOException(error)
    }

    if(!sout.toString().trim().isEmpty() && Config.verbose) {
        println "CURL/OUTPUT> ${sout}"
    }
    if(!serr.toString().trim().isEmpty() && Config.verbose) {
        println "CURL/ERROR> ${serr}"
    }

    return 0
}

def gerritLabel(label, score, msgBody = "") {
    def notify = score < 0 ? ', "notify" : "OWNER"' : ''
    def jsonPayload = '{"labels":{"' + label + '":' + score + '},' +
                        ' "message": "' + msgBody + '"' +
                        notify + ", ${Config.addVerifiedTag} }"

    return postToGerrit("a/changes/" + Change.changeJson._number +
        "/revisions/" + Change.metaData.sha1 + "/review", jsonPayload)
}


def applyVerificationLabel(verificationScore) {
    if(verificationScore == 0) {
        return
    }

    def msgList = Builds.buildsVerification.collect { type,build -> [
            'type': type,
            'res': build.result.toString(),
            'url': build.getAbsoluteUrl() + "consoleText"
        ]
    }

    def msgBody = msgList.collect {
        "${Config.resTicks[it.res]} ${it.type} : ${it.res}\n    (${it.url})"
    } .join('\n')

    def addVerifiedExit = gerritLabel('Verified', verificationScore, msgBody)

    if(addVerifiedExit == 0) {
        println "----------------------------------------------------------------------------"
        println "Gerrit Review: Verified=" + verificationScore + " to change " +
            Change.changeJson._number + "/" + Change.metaData.sha1
        println "----------------------------------------------------------------------------"
    }

    return addVerifiedExit
}

def findCodestyleFilesInLog() {
    def codestyleFiles = []
    def needsFormatting = false
    def codestyleLogReader = Builds.buildCodeStyle.getLogReader()
    codestyleLogReader.eachLine {
        needsFormatting = needsFormatting || (it ==~ /.*Need Formatting.*/)
        if(needsFormatting && it ==~ /\[.*\]/) {
        codestyleFiles += it.substring(1,it.length()-1)
        }
    }

    return codestyleFiles
}

def applyCodestyleLabel(codeStyleScore) {
    if(codeStyleScore == 0) {
        return
    }

    def files = findCodestyleFilesInLog()
    def changeNum = Change.changeJson._number
    def formattingMsg = codeStyleScore < 0 ?
        ('The following files need formatting:\n    ' + files.join('\n    ')) :
        'All files are correctly formatted'
    def res = Builds.resultCodeStyle.toString()
    def url = Builds.buildCodeStyle.getAbsoluteUrl() + "consoleText"

    def msgBody = "${Config.resTicks[res]} $formattingMsg\n    (${url})"

    def addCodeStyleExit = gerritLabel('Code-Style', codeStyleScore, msgBody)
    if(addCodeStyleExit == 0) {
        println "----------------------------------------------------------------------------"
        println "Gerrit Review: Code-Style=" + codeStyleScore + " to change " + changeNum + "/" +
            Change.metaData.sha1
        println "----------------------------------------------------------------------------"
    }

    return addCodeStyleExit
}

def getChangedFiles() {
    URL filesUrl = new URL(String.format("%schanges/%s/revisions/%s/files/",
        Config.gerrit, Change.metaData.changeNum, Change.metaData.sha1))
    def files = filesUrl.getText().substring(5)
    def filesJson = new JsonSlurper().parseText(files)
    return filesJson.keySet().findAll { it != "/COMMIT_MSG" }
}

def getWorkspace(){
    println "workspace: ${WORKSPACE}"
    def cwd = new File("${WORKSPACE}")
    println "cwd: ${cwd}"
    return cwd
}

def executeBash(cwd, command) {
    def sout = new StringBuilder(), serr = new StringBuilder()
    println "SH: ${command}"
    def shell = command.execute([],cwd)
    shell.consumeProcessOutput(sout, serr)
    shell.waitFor()
    println "OUT: ${sout}"
    println "ERR: ${serr}"
}

def initializeGit(cwd){
    executeBash(cwd, "git fetch https://gerrit.googlesource.com/gerrit ${Change.metaData.ref}")
    executeBash(cwd, "git checkout FETCH_HEAD")
    executeBash(cwd, "git fetch origin ${Change.metaData.branch}")
    executeBash(cwd, "git config user.name '${Config.gitUser}'")
    executeBash(cwd, "git config user.email '${Config.gitEmail}'")
    executeBash(cwd, "git merge --no-commit --no-edit --no-ff FETCH_HEAD")
}

def collectBuildTools(cwd){
    if(new java.io.File("${cwd}/BUCK").exists()) {
        Builds.tool = "buck"
    } else if(new java.io.File("${cwd}/BUILD").exists()) {
        Builds.tool = "bazel"
    } else {
        throw new FileNotFoundException("Neither BUCK- nor BUILD-file found.")
    }
}

def collectBuildModes(){
    if(Change.metaData.branch == "master" || Change.metaData.branch == "stable-2.15") {
        Builds.modes += "notedb"
    }
    if(Change.metaData.branch == "master" || Change.metaData.branch == "stable-2.15" ||
        Change.metaData.branch == "stable-2.14") {

        def changedFiles = getChangedFiles()
        def polygerritFiles = changedFiles.findAll { it.startsWith("polygerrit-ui") }

        if(polygerritFiles.size() > 0) {
            if(changedFiles.size() == polygerritFiles.size()) {
                println "Only PolyGerrit UI changes detected, skipping other test modes..."
                Builds.modes = ["polygerrit"]
            } else {
                println "PolyGerrit UI changes detected, adding 'polygerrit' validation..."
                Builds.modes += "polygerrit"
            }
        }
    }
}

def formatBuildStep(buildjob, mode) {
    def retries = buildjob == "Gerrit-codestyle" ? 1 : Config.retryTimes
    return {
        retry(retries){
            def slaveBuild = build job: "${buildjob}", parameters: [
                string(name: 'REFSPEC', value: Change.metaData.ref),
                string(name: 'BRANCH', value: Change.metaData.sha1),
                string(name: 'CHANGE_URL', value: Change.metaData.changeUrl),
                string(name: 'MODE', value: mode),
                string(name: 'TARGET_BRANCH', value: Change.metaData.branch)
            ], propagate: false
            if (buildjob == "Gerrit-codestyle"){
                Builds.buildCodeStyle = slaveBuild.rawBuild
                Builds.resultCodeStyle = slaveBuild.rawBuild.result
            } else {
                Builds.buildsVerification["${mode}"] = slaveBuild.rawBuild
                Builds.resultsVerification["${mode}"] = slaveBuild.rawBuild.result
            }
        }
    }
}

def fetchChange(){
    def requestedChangeId = params.get("CHANGE_ID")
    def queryUrl =
        new URL("${Config.gerrit}changes/${requestedChangeId}/?pp=0&O=3")
    def response = queryUrl.getText().substring(5)
    def jsonSlurper = new JsonSlurper()
    Change.changeJson = jsonSlurper.parseText(response)
}

def extractChangeMetaData(){
    Change.metaData.sha1 = Change.changeJson.current_revision
    Change.metaData.changeNum = Change.changeJson._number
    Change.metaData.branch = Change.changeJson.branch
    Change.metaData.revision = Change.changeJson.revisions.get(Change.metaData.sha1)
    Change.metaData.ref = Change.metaData.revision.ref
    Change.metaData.patchNum = Change.metaData.revision._number
    Change.metaData.changeUrl = Config.gerrit + "#/c/" + Change.metaData.changeNum +
        "/" + Change.metaData.patchNum
}

def getVoteScore(acc, res) {
    if(res == null || res == Result.ABORTED) {
        return 0
    }

    switch(acc) {
            case 0: return 0
            case 1:
            if(res == null) {
                return 0;
            }
            switch(res) {
                case Result.SUCCESS: return +1;
                case Result.FAILURE: return -1;
                default: return 0;
            }
            case -1: return -1
    }
}

node('master') {
    git url: "${Config.gerrit}${Config.repository}"
    stage('Preparing'){
        fetchChange()
        extractChangeMetaData()
        def build = currentBuild.rawBuild

        build.setDescription(
            """<a href='${Change.metaData.changeUrl}' target='_blank'>""" +
                """Change #${Change.metaData.changeNum}""" +
            """</a>""")

        if(Change.metaData.sha1 == null) {
            error("[WARNING] Skipping change " + Change.changeJson.change_id +
                " because it does not have any current revision or patch-set")
        }
        def cwd = getWorkspace()
        initializeGit(cwd)
        collectBuildTools(cwd)
        collectBuildModes()
    }
    stage('Check Codestyle'){
        println "Checking codestyle of " + Change.metaData.changeUrl

        parallel "Gerrit-codestyle": formatBuildStep("Gerrit-codestyle", "reviewdb")
    }
    stage('Verification'){
        println "Verifying Change " + Change.metaData.changeUrl

        parallel Builds.modes.collectEntries {
            ["Gerrit-verification(${it})" : formatBuildStep("Gerrit-verifier-${Builds.tool}", it)]
        }
    }
    stage('Vote'){
        if(Builds.resultCodeStyle) {
            def codeStyleScore = getVoteScore(1, Builds.resultCodeStyle)
            applyCodestyleLabel(codeStyleScore)
        }

        def verificationResults = Builds.resultsVerification.collect {
            k, v -> v
        }
        def verificationScore = verificationResults.inject(1) {
            acc, buildResult -> getVoteScore(acc, buildResult)
        }
        applyVerificationLabel(verificationScore)

        def combinedScore = Builds.resultCodeStyle ?
            getVoteScore(verificationScore, Builds.resultCodeStyle) : verificationScore

        switch(combinedScore) {
            case 0: currentBuild.rawBuild.result = Result.ABORTED
                    break
            case 1: currentBuild.rawBuild.result = Result.SUCCESS
                    break
            case -1: currentBuild.rawBuild.result = Result.FAILURE
                    break
        }
    }
}
