// Copyright (C) 2015 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import hudson.model.*
import hudson.AbortException
import hudson.console.HyperlinkNote
import java.util.concurrent.CancellationException
import groovy.json.*
import java.text.*

verbose = true

class Config {
  static String gerrit = "https://gerrit-review.googlesource.com/"
  static String repository = "gerrit"
  static long curlTimeout = 10000
  static String addVerifiedTag = " \"tag\" : \"autogenerated:gerrit-ci:addVerified\" "
  static Set<String> codeStyleBranches = ["master", "stable-2.14", "stable-2.15"]
  static resTicks = [ 'ABORTED':'\u26aa', 'SUCCESS':'\u2705', 'FAILURE':'\u274c' ]
}

class Change {
    static Map changeJson = [:]
    static String sha1 = ""
    static String changeNum = ""
    static String branch = ""
    static Map revision = [:]
    static String ref = ""
    static String patchNum = ""
    static String changeUrl = ""
}

class Builds {
    static String tool = ""
    static Set<String> modes = ["reviewdb"]
    static Result resultCodeStyle = null
    static Run buildCodeStyle = null
    static Map resultsVerification = [:]
    static Map buildsVerification = [:]
}

def gerritPost(url, jsonPayload) {
  def error = ""
  def gerritPostUrl = Config.gerrit + url
  def curl = ['curl',
  '-n', '-s', '-S',
  '-X', 'POST', '-H', 'Content-Type: application/json',
  '--data-binary', jsonPayload,
    gerritPostUrl ]
  if(verbose) { println "CURL/EXEC> $curl" }
  def proc = curl.execute()
  def sout = new StringBuffer(), serr = new StringBuffer()
  proc.consumeProcessOutput(sout, serr)
  proc.waitForOrKill(Config.curlTimeout)
  def curlExit = proc.exitValue()
  if(curlExit != 0) {
    error = "$curl **FAILED** with exit code = $curlExit"
    println error
    throw new IOException(error)
  }

  if(!sout.toString().trim().isEmpty() && verbose) {
    println "CURL/OUTPUT> $sout"
  }
  if(!serr.toString().trim().isEmpty() && verbose) {
    println "CURL/ERROR> $serr"
  }

  return 0
}

def gerritLabelVerify(verified) {
  if(verified == 0) {
    return;
  }

  def msgList = Builds.buildsVerification.collect { type,build ->
    [ 'type': type, 'res': build.result.toString(), 'url': build.getAbsoluteUrl() + "consoleText" ]
  } sort { a,b -> a['res'].compareTo(b['res']) }

  def msgBody = msgList.collect {
    "${Config.resTicks[it.res]} ${it.type} : ${it.res}\n    (${it.url})"
  } .join('\n')

  def addVerifiedExit = gerritLabel('Verified', verified, msgBody)
  if(addVerifiedExit == 0) {
    println "----------------------------------------------------------------------------"
    println "Gerrit Review: Verified=" + verified + " to change " + Change.changeNum +
      "/" + Change.sha1
    println "----------------------------------------------------------------------------"
  }

  return addVerifiedExit
}

def findCodestyleFilesInLog() {
  def codestyleFiles = []
  def needsFormatting = false
  def codestyleLogReader = Builds.buildCodeStyle.getLogReader()
  codestyleLogReader.eachLine {
    needsFormatting = needsFormatting || (it ==~ /.*Need Formatting.*/)
    if(needsFormatting && it ==~ /\[.*\]/) {
      codestyleFiles += it.substring(1,it.length()-1)
    }
  }

  return codestyleFiles
}

def gerritLabelCodestyle(cs, files) {
  if(cs == 0) {
    return
  }


  def formattingMsg = cs < 0 ? ('The following files need formatting:\n    ' + files.join('\n    ')) : 'All files are correctly formatted'
  def res = Builds.resultCodeStyle.toString()
  def url = Builds.buildCodeStyle.getAbsoluteUrl() + "consoleText"

  def msgBody = "${Config.resTicks[res]} $formattingMsg\n    (${url})"

  def addCodeStyleExit = gerritLabel('Code-Style', cs, msgBody)
  if(addCodeStyleExit == 0) {
    println "----------------------------------------------------------------------------"
    println "Gerrit Review: Code-Style=" + cs + " to change " + Change.changeNum + "/" + Change.sha1
    println "----------------------------------------------------------------------------"
  }

  return addCodeStyleExit
}

def gerritLabel(label, score, msgBody = "") {
  def notify = score < 0 ? ', "notify" : "OWNER"' : ''
  def jsonPayload = '{"labels":{"' + label + '":' + score + '},' +
                    ' "message": "' + msgBody + '"' +
                    notify + ", ${Config.addVerifiedTag} }"

  return gerritPost("a/changes/" + Change.changeNum + "/revisions/" + Change.sha1 + "/review",
                    jsonPayload)
}

def getVerified(acc, res) {
  if(res == null || res == Result.ABORTED) {
    return 0
  }

  switch(acc) {
        case 0: return 0
        case 1:
          if(res == null) {
            return 0;
          }
          switch(res) {
            case Result.SUCCESS: return +1;
            case Result.FAILURE: return -1;
            default: return 0;
          }
        case -1: return -1
  }
}

def getChangedFiles() {
  URL filesUrl = new URL(String.format("%schanges/%s/revisions/%s/files/",
      Config.gerrit, Change.changeNum, Change.sha1))
  def files = filesUrl.getText().substring(5)
  def filesJson = new JsonSlurper().parseText(files)
  filesJson.keySet().findAll { it != "/COMMIT_MSG" }
}

def buildForMode(buildName,mode="reviewdb",retryTimes = 1) {
    def propagate = retryTimes == 1 ? false : true
    return {
        catchError{
            retry(retryTimes){
                def slaveBuild = build job: "${buildName}", parameters: [
                    string(name: 'REFSPEC', value: Change.ref),
                    string(name: 'BRANCH', value: Change.sha1),
                    string(name: 'CHANGE_URL', value: Change.changeUrl),
                    string(name: 'MODE', value: mode),
                    string(name: 'TARGET_BRANCH', value: Change.branch)
                ], propagate: propagate
                if (buildName == "Gerrit-codestyle"){
                    Builds.buildCodeStyle = slaveBuild.rawBuild
                    Builds.resultCodeStyle = slaveBuild.rawBuild.result
                } else {
                    Builds.buildsVerification["${mode}"] = slaveBuild.rawBuild
                    Builds.resultsVerification["${mode}"] = slaveBuild.rawBuild.result
                }
            }
        }
    }
}

def getWorkspace(){
    println "workspace: ${WORKSPACE}"
    def cwd = new File("${WORKSPACE}")
    println "cwd: ${cwd}"
    return cwd
}

def sh(cwd, command) {
    def sout = new StringBuilder(), serr = new StringBuilder()
    println "SH: $command"
    def shell = command.execute([],cwd)
    shell.consumeProcessOutput(sout, serr)
    shell.waitForOrKill(30000)
    println "OUT: $sout"
    println "ERR: $serr"
}

def initializeGit(cwd){
    sh(cwd, "git fetch origin ${Change.ref}")
    sh(cwd, "git checkout FETCH_HEAD")
    sh(cwd, "git fetch origin ${Change.branch}")
    sh(cwd, 'git config user.name "Jenkins Build"')
    sh(cwd, 'git config user.email "jenkins@gerritforge.com"')
    sh(cwd, 'git merge --no-commit --no-edit --no-ff FETCH_HEAD')
}

def collectBuildTool(cwd){
    if(new java.io.File("$cwd/BUCK").exists()) {
        Builds.tool = "buck"
    } else if(new java.io.File("$cwd/BUILD").exists()) {
        Builds.tool = "bazel"
    }
}

def collectBuildModes(){
  if(Change.branch == "master" || Change.branch == "stable-2.15") {
    Builds.modes += "notedb"
  }

  if(Change.branch == "master" || Change.branch == "stable-2.15" ||
    Change.branch == "stable-2.14") {
    def changedFiles = getChangedFiles()
    def polygerritFiles = changedFiles.findAll { it.startsWith("polygerrit-ui") }

    if(polygerritFiles.size() > 0) {
      if(changedFiles.size() == polygerritFiles.size()) {
        println "Only PolyGerrit UI changes detected, skipping other test modes..."
        Builds.modes = ["polygerrit"]
      } else {
        println "PolyGerrit UI changes detected, adding 'polygerrit' validation..."
        Builds.modes += "polygerrit"
      }
    }
  }
}

def flakyBuilds() {
    def flaky = Builds.buildsVerification.findAll { it.value.result == null ||
        it.value.result != Result.SUCCESS }
    if(flaky.size() == Builds.resultsVerification.size()) {
        return []
    }

    def retryBuilds = []

    flaky.each {
        def mode = it.key
        Builds.resultsVerification.remove(mode)
        Builds.buildsVerification.remove(mode)
        retryBuilds += mode
    }
    return retryBuilds
}

def fetchChange(){
    def requestedChangeId = params.get("CHANGE_ID")
    def queryUrl =
        new URL("${Config.gerrit}changes/${requestedChangeId}/?pp=0&O=3")
    def response = queryUrl.getText().substring(5)
    def jsonSlurper = new JsonSlurper()
    Change.changeJson = jsonSlurper.parseText(response)
}

def extractChangeMetaData(){
    Change.sha1 = Change.changeJson.current_revision
    Change.changeNum = Change.changeJson._number
    Change.branch = Change.changeJson.branch
    Change.revision = Change.changeJson.revisions.get(Change.sha1)
    Change.ref = Change.revision.ref
    Change.patchNum = Change.revision._number
    Change.changeUrl = Config.gerrit + "#/c/" + Change.changeNum +
        "/" + Change.patchNum
}

node('master') {
    git url: "${Config.gerrit}${Config.repository}"
    stage('Preparing'){
        fetchChange()
        extractChangeMetaData()
        def build = currentBuild.rawBuild

        build.setDescription(
            """<a href='${Change.changeUrl}' target='_blank'>""" +
                """Change #${Change.changeNum}""" +
            """</a>""")

        if(Change.sha1 == null) {
            error("[WARNING] Skipping change ${Change.changeJson.change_id}" +
                " because it does not have any current revision or patch-set")
        }
        def cwd = getWorkspace()
        initializeGit(cwd)
        collectBuildTool(cwd)
        collectBuildModes()
    }
    stage('Check Codestyle'){
        println "Checking codestyle of ${Change.changeUrl}"

        parallel "Gerrit-codestyle": buildForMode("Gerrit-codestyle")
    }
    stage('Verification'){
        println "Verifying Change ${Change.changeUrl}"

        parallel Builds.modes.collectEntries {
            ["Gerrit-verification(${it})" : buildForMode("Gerrit-verifier-${Builds.tool}", it)]
        }
    }
    stage('Retry Flaky Builds'){
        def flakyBuildsModes = flakyBuilds()
        if (flakyBuildsModes.size() > 0){
            println "Retrying flaky builds."
            parallel flakyBuildsModes.collectEntries {
                ["Gerrit-verification(${it})" :
                    buildForMode("Gerrit-verifier-${Builds.tool}", it, 3)]
            }
        }
    }
    stage('Vote'){
        if(Builds.resultCodeStyle) {
            def resCodeStyle = getVerified(1, Builds.resultCodeStyle)
            gerritLabelCodestyle(resCodeStyle, findCodestyleFilesInLog())
        }

        def verificationResults = Builds.resultsVerification.collect {
            k, v -> v
        }
        def resVerify = verificationResults.inject(1) {
            acc, buildResult -> getVerified(acc, buildResult)
        }
        gerritLabelVerify(resVerify)

        def resAll = Builds.resultCodeStyle ?
            getVerified(resVerify, Builds.resultCodeStyle) : resVerify

        switch(resAll) {
            case 0: currentBuild.rawBuild.result = Result.ABORTED
                    break
            case 1: currentBuild.rawBuild.result = Result.SUCCESS
                    break
            case -1: currentBuild.rawBuild.result = Result.FAILURE
                    break
        }
    }
}
